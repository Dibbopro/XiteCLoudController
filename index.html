<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multi Cloud Shell Commander</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #111;
      color: #eee;
      margin: 0;
    }
    .wrapper {
      max-width: 800px;
      margin: 40px auto;
      padding: 20px 24px;
      background: #1c1c1c;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }
    h1 {
      margin-top: 0;
      font-size: 1.6rem;
    }
    label {
      display: block;
      margin: 12px 0 4px;
      font-size: 0.9rem;
      color: #ccc;
    }
    input, textarea {
      width: 100%;
      box-sizing: border-box;
      padding: 8px 10px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #111;
      color: #eee;
      font-family: monospace;
      font-size: 0.9rem;
    }
    textarea {
      min-height: 100px;
      resize: vertical;
    }
    button {
      margin-top: 12px;
      padding: 8px 16px;
      background: #0b84ff;
      border: none;
      border-radius: 4px;
      color: white;
      font-weight: 600;
      cursor: pointer;
    }
    button:hover {
      background: #096cd1;
    }
    pre {
      margin-top: 16px;
      padding: 10px;
      background: #000;
      border-radius: 4px;
      font-size: 0.85rem;
      max-height: 300px;
      overflow: auto;
      white-space: pre-wrap;
    }
    .note {
      font-size: 0.8rem;
      color: #aaa;
      margin-top: 4px;
    }
  </style>
</head>
<body>
<div class="wrapper">
  <h1>Multi Cloud Shell Commander</h1>
  <p>Type a shell command below. Every Cloud Shell agent will execute it when it sees the update.</p>

  <label for="token">GitHub personal access token (repo contents: read/write). Not stored anywhere:</label>
  <input id="token" type="password" placeholder="github_pat_..." autocomplete="off" />

  <p class="note">
    The token stays only in this browser tab. Do <strong>not</strong> hard‑code it into this file or share it.
  </p>

  <label for="command">Command to run (bash):</label>
  <textarea id="command" placeholder="echo &quot;Hello from $(gcloud config get-value project)&quot;"></textarea>

  <button id="runBtn">Run on all Cloud Shells</button>

  <pre id="status"></pre>
</div>

<script>
  // === CONFIG: your repo ===
  const owner  = "Dibbopro";
  const repo   = "XiteCLoudController";
  const branch = "main";
  const path   = "latest-command.sh";
  // =========================

  function encodeBase64(str) {
    return btoa(unescape(encodeURIComponent(str)));
  }

  async function fetchCurrentSha(headers, statusEl) {
    const url =
      `https://api.github.com/repos/${owner}/${repo}/contents/` +
      `${encodeURIComponent(path)}?ref=${encodeURIComponent(branch)}&t=${Date.now()}`;

    const res = await fetch(url, { headers });

    if (res.status === 404) {
      statusEl.textContent += "\nFile does not exist yet; will create it.";
      return null;
    }

    if (!res.ok) {
      const text = await res.text();
      throw new Error(
        "GET " + path + " failed: " +
        res.status + " " + res.statusText + "\n" + text
      );
    }

    const data = await res.json();
    const sha = data.sha;
    statusEl.textContent += "\nCurrent file SHA: " + sha;
    return sha;
  }

  async function updateFile(headers, body, statusEl, attempt = 1) {
    const url =
      `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}`;

    const res = await fetch(url, {
      method: "PUT",
      headers: { ...headers, "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const text = await res.text();
    let parsed;
    try { parsed = JSON.parse(text); } catch (_) {}

    if (res.status === 409) {
      statusEl.textContent +=
        `\n409 conflict on attempt ${attempt} (SHA mismatch).`;

      if (attempt >= 2) {
        statusEl.textContent +=
          "\nGiving up after 2 attempts.\nRaw response:\n" + text;
        return;
      }

      // Re‑fetch SHA and retry once
      statusEl.textContent += "\nRe‑fetching SHA and retrying...";
      try {
        const newSha = await fetchCurrentSha(headers, statusEl);
        if (newSha) body.sha = newSha;
        else delete body.sha;
      } catch (err) {
        statusEl.textContent += "\nFailed to re‑fetch SHA: " + err;
        return;
      }

      return updateFile(headers, body, statusEl, attempt + 1);
    }

    if (!res.ok) {
      statusEl.textContent =
        "Error updating file:\n" +
        res.status + " " + res.statusText + "\n" + text;
      return;
    }

    const commitSha = parsed && parsed.commit && parsed.commit.sha
      ? parsed.commit.sha.slice(0, 7)
      : "(unknown)";

    statusEl.textContent +=
      "\nUpdate successful." +
      "\nCommit: " + commitSha +
      "\nAll running Cloud Shell agents will now execute it.";
  }

  async function runCommand() {
    const tokenEl  = document.getElementById("token");
    const cmdEl    = document.getElementById("command");
    const statusEl = document.getElementById("status");

    const token = tokenEl.value.trim();
    const cmd   = cmdEl.value.trim();

    if (!token) {
      statusEl.textContent = "Error: GitHub token is required.";
      return;
    }
    if (!cmd) {
      statusEl.textContent = "Error: Command is empty.";
      return;
    }

    statusEl.textContent = "Step 1/2: Fetching current file SHA from GitHub...";

    const headers = {
      "Authorization": "Bearer " + token,
      "Accept": "application/vnd.github+json"
    };

    let sha = null;
    try {
      sha = await fetchCurrentSha(headers, statusEl);
    } catch (err) {
      statusEl.textContent += "\n" + err;
      return;
    }

    statusEl.textContent += "\nStep 2/2: Updating file...";

    const nowIso = new Date().toISOString();
    const scriptContent = `#!/usr/bin/env bash
set -euo pipefail
# updated_from_web: ${nowIso}

${cmd}
`;

    const body = {
      message: "Update latest-command.sh from web UI",
      content: encodeBase64(scriptContent),
      branch: branch
    };
    if (sha) body.sha = sha;

    await updateFile(headers, body, statusEl);
  }

  document.getElementById("runBtn").addEventListener("click", () => {
    runCommand().catch(err => {
      document.getElementById("status").textContent =
        "Unexpected error: " + err;
    });
  });
</script>
</body>
</html>
