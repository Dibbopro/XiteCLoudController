<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multi Cloud Shell Commander</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #111;
      color: #eee;
      margin: 0;
    }
    .wrapper {
      max-width: 800px;
      margin: 40px auto;
      padding: 20px 24px;
      background: #1c1c1c;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }
    h1 {
      margin-top: 0;
      font-size: 1.6rem;
    }
    label {
      display: block;
      margin: 12px 0 4px;
      font-size: 0.9rem;
      color: #ccc;
    }
    input, textarea {
      width: 100%;
      box-sizing: border-box;
      padding: 8px 10px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #111;
      color: #eee;
      font-family: monospace;
      font-size: 0.9rem;
    }
    textarea {
      min-height: 100px;
      resize: vertical;
    }
    button {
      margin-top: 12px;
      padding: 8px 16px;
      background: #0b84ff;
      border: none;
      border-radius: 4px;
      color: white;
      font-weight: 600;
      cursor: pointer;
    }
    button:hover {
      background: #096cd1;
    }
    pre {
      margin-top: 16px;
      padding: 10px;
      background: #000;
      border-radius: 4px;
      font-size: 0.85rem;
      max-height: 300px;
      overflow: auto;
      white-space: pre-wrap;
    }
    .note {
      font-size: 0.8rem;
      color: #aaa;
      margin-top: 4px;
    }
  </style>
</head>
<body>
<div class="wrapper">
  <h1>Multi Cloud Shell Commander</h1>
  <p>Type a shell command below. Every Cloud Shell agent will execute it when it sees the update.</p>

  <label for="token">GitHub personal access token (repo contents: read/write). Not stored anywhere:</label>
  <input id="token" type="password" placeholder="github_pat_..." autocomplete="off" />

  <p class="note">
    The token stays only in this browser tab. Do <strong>not</strong> hard‑code it into this file or share it.
  </p>

  <label for="command">Command to run (bash):</label>
  <textarea id="command" placeholder="echo &quot;Hello from $(gcloud config get-value project)&quot;"></textarea>

  <button id="runBtn">Run on all Cloud Shells</button>

  <pre id="status"></pre>
</div>

<script>
  // === CONFIG: set these to your repo ===
  const owner  = "Dibbopro";
  const repo   = "XiteCLoudController";
  const branch = "main";
  const path   = "latest-command.sh";
  // ======================================

  function encodeBase64(str) {
    return btoa(unescape(encodeURIComponent(str)));
  }

  async function runCommand() {
    const tokenEl  = document.getElementById("token");
    const cmdEl    = document.getElementById("command");
    const statusEl = document.getElementById("status");

    const token = tokenEl.value.trim();
    const cmd   = cmdEl.value.trim();

    if (!token) {
      statusEl.textContent = "Error: GitHub token is required.";
      return;
    }
    if (!cmd) {
      statusEl.textContent = "Error: Command is empty.";
      return;
    }

    statusEl.textContent = "Step 1/2: Getting current file info from GitHub...";

    const headers = {
      "Authorization": "Bearer " + token,
      "Accept": "application/vnd.github+json"
    };

    let existingSha = null;

    // ---- Step 1: get current file (to obtain correct SHA) ----
    try {
      const getUrl =
        `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}?ref=${branch}`;

      const getRes = await fetch(getUrl, { headers });

      if (getRes.status === 404) {
        // File does not exist yet → we'll create it; leave existingSha = null
        statusEl.textContent += "\nFile does not exist yet, will create it.";
      } else if (!getRes.ok) {
        const text = await getRes.text();
        statusEl.textContent =
          "Error reading " + path + ":\n" +
          getRes.status + " " + getRes.statusText + "\n" + text;
        return;
      } else {
        const fileData = await getRes.json();
        existingSha = fileData.sha;  // This is the SHA GitHub expects for update
        statusEl.textContent += "\nCurrent SHA: " + existingSha;
      }
    } catch (err) {
      statusEl.textContent = "Network error while reading file: " + err;
      return;
    }

    // ---- Step 2: send updated content ----
    statusEl.textContent += "\nStep 2/2: Updating file on GitHub...";

    const scriptContent = `#!/usr/bin/env bash
set -euo pipefail

${cmd}
`;

    const body = {
      message: "Update latest-command.sh from web UI",
      content: encodeBase64(scriptContent),
      branch: branch
    };
    if (existingSha) {
      body.sha = existingSha; // Only include SHA if the file already exists
    }

    try {
      const putUrl =
        `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}`;

      const putRes = await fetch(putUrl, {
        method: "PUT",
        headers: { ...headers, "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });

      const text = await putRes.text();
      let parsed;
      try { parsed = JSON.parse(text); } catch (_) {}

      if (putRes.status === 409) {
        // SHA mismatch / conflict
        statusEl.textContent =
          "409 conflict from GitHub (SHA mismatch).\n" +
          "Usually this means the file changed between reading and writing.\n" +
          "Try reloading the page and sending the command again.\n\n" +
          "Raw response:\n" + text;
        return;
      }

      if (!putRes.ok) {
        statusEl.textContent =
          "Error updating file:\n" +
          putRes.status + " " + putRes.statusText + "\n" + text;
        return;
      }

      const commitSha = parsed && parsed.commit && parsed.commit.sha
        ? parsed.commit.sha.slice(0, 7)
        : "(unknown)";

      statusEl.textContent =
        "Command sent at " + new Date().toLocaleTimeString() +
        "\nCommit: " + commitSha +
        "\nAll running Cloud Shell agents will now execute it.";
    } catch (err) {
      statusEl.textContent = "Network error while updating file: " + err;
    }
  }

  document.getElementById("runBtn").addEventListener("click", () => {
    runCommand().catch(err => {
      document.getElementById("status").textContent =
        "Unexpected error: " + err;
    });
  });
</script>
</body>
</html>
